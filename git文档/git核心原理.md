# git核心原理
git最核心的思想说明

## 版本机制
git是一个不同于svn的版本控制系统，它是一个分布式版控制系统，所以它没有像svn一样的版本号(也没法儿有)。
因为它是分 *分布式* 的，每个人那边都有不同的改动，所以它是以一种统一的规则建立的 *版本号*

git会给所有的文件做一个hash计算，并得到一个16进制表示的字符串如： 5b036cefdd302c70fc4317c34076ca50dd08067a

每做一次提交其实就是把整个目录树放在一起，然后做一个hash。所以git的每个提交里是记录了这个版本的所有文件的！(这点很重要！)

只要文件一样，文件的hash值就会一样，只要整个目录和文件一样，目录树的hash值就会一样。git就是通这种方式实现的分布式。

![git版本](./dots/git_tree.dot)

## 提交
上面讲到提交其实是一个hash指向的目录树，但是这样每个提交之前就没有联系。而我们需要知道版本的变化历史，所有提交里就增加了父级提交的hash，如果提交是通过合并操作得到的，将会有两个父级提交。(实际上还有提交人，提交时间等其它信息，细节咱们先忽略)

如果我们需要查看历史版本，只要找到当前的提交id, 然后一直找父级提交id，这样就能找到所有的提交记录。

![git提交示意](./dots/git_commit.dot)

(需要注意上图的a,b,c,d是没有顺序的，用a,b,c只是为了方便画)

## 分支和tag
git的分支跟svn或人直觉上的那种分支有些不一样。git分支更像是种“木桩”，git用这个木桩(分支)固定了一个提交,让它不再“随风飘...”

![git分支和tag](./dots/git_branch.dot)

上图就是git的分支和tag，其实在git里分支和tag的区别很小，从图片就可以看出来它们其实都是指向一个提交而己。

不同的只是：如果当前在某个分支上，这时如果进行一次提交，那分支的指向会跟着移动到最新的这个提交上来，而tag的指向是固定不动的。

## HEAD指针
HEAD是个殊表指针，表示“当前”。 HEAD会指向一个分支或一个提交。

当HEAD指向分支br1时，这我们就处于分支br1下。

当HEAD指向一个提交时，这时我们就处理“分离头”的状态下, 表示我们现在不在任何一个分支上。

当我们通过git checkout切换分支时实际上我们就是在操作这个HEAD指针而己，git reset到一个非分支指向的提交时其实只是调整了下HEAD指向。

## gc(垃圾回收)
git gc默认是需要手动操作的，如果一个提交没有任何的分支、tag、HEAD指向它，这个提交就会被回收，如果一个文件没有任何提交指向它，那么这个文件将被回收。

所以一般来说为了保证己上线的代码不至于丢掉，我们会要求所以上线必需打个tag，这样子可以避免分支被删掉或重置掉时找不到历史提交的尴尬。
